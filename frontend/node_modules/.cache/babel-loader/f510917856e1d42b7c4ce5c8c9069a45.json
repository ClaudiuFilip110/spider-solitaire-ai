{"ast":null,"code":"import '../assets/css/card.css';\nimport { card } from './CardGenerator';\nimport applauseAudio from '../assets/sound/applause.mp3';\nimport wrongAudio from '../assets/sound/wrong.mp3';\nexport const createLinked = element => {\n  // remaining cards is array of objects but we need to transform every object to linked list object\n  class Link {\n    constructor(val) {\n      this.val = val;\n      this.next = null;\n    }\n  }\n  return new Link(element);\n};\nexport const removeHighlight = async remove => {\n  // remove card or cards activation/selected/red bordered\n  while (remove !== null) {\n    remove.val.active = false;\n    remove = remove.next;\n  }\n};\nexport const removeCardOldPlace = (remove, allCards) => {\n  // remove card from it's old place\n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    let prev;\n    while (element !== null) {\n      if (element === remove) {\n        prev === undefined ? allCards[index] = null : prev.next = null; // control for if column will not have any cards after placement\n      }\n      prev = element;\n      element = element.next;\n    }\n  }\n};\nexport const setCardDisplay = allCards => {\n  // traverse every card and set visibility to true if it's last element \n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    if (element !== null) {\n      while (element.next !== null) {\n        element = element.next;\n      }\n      element.val.show = true;\n    }\n  }\n};\nexport const anyBlank = allCards => {\n  // check if any blank column exist\n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    if (element === null) {\n      return false;\n    }\n  }\n  return true;\n};\nexport const clickGetCards = (request, allCards, remCards) => {\n  // check request bcs only 5 * 10 cards will distribute\n  request += 1;\n  // add new cards to placing cards\n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    if (element === null) {\n      // placing to empty columns\n      element = createLinked(remCards.shift());\n      allCards[index] = element;\n    } else {\n      while (element.next !== null) {\n        element = element.next;\n      }\n      element.next = createLinked(remCards.shift());\n    }\n  }\n  setCardDisplay(allCards);\n  return {\n    request,\n    remCards\n  };\n};\nexport const checkComplete = (allCards, complete, test) => {\n  // traverse in every card and if rank reaches 13 means sorting complete\n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    let rank = 1;\n    while (element !== null && element.next !== null) {\n      if (element.val.show === true) {\n        let next_value = +element.next.val.value - 1;\n        let cur_value = +element.val.value;\n        if (next_value === cur_value) {\n          if (rank === 1) {\n            var node = element; // hold head node bcs if sorting complete, we will need to remove from that index\n          }\n          rank += 1;\n          if (rank === 13) {\n            test && new Audio(applauseAudio).play();\n            complete += 1;\n            removeCardOldPlace(node, allCards);\n            test && alert(\"You Have Completed a Deck\");\n          }\n        } else rank = 1; // reset rank value for new deck\n      }\n      element = element.next;\n    }\n  }\n  setCardDisplay(allCards);\n  return {\n    node,\n    complete\n  };\n};\nexport const firstClick = item => {\n  if (item !== null) {\n    let iter = 0; // how many cards will be select\n    let head = item; // need to hold head node because after control item's next, clicked item will be lost\n\n    while (item.next !== null) {\n      let next_value = +item.next.val.value - 1;\n      let cur_value = +item.val.value;\n      // check cards if in correct order\n      if (next_value !== cur_value || item.val.show === false) {\n        return false;\n      }\n      item = item.next;\n      iter += 1;\n    }\n    let node = head;\n\n    // if every item under clicked item have correct sort, activate all\n    for (let index = 0; index <= iter; index++) {\n      head.val.active = true;\n      head = head.next;\n    }\n    return node;\n  }\n};\nexport const secondClick = (item, highlighted, allCards, index) => {\n  let undoControl = false;\n  if (item === null) {\n    removeCardOldPlace(highlighted, allCards);\n    allCards[index] = highlighted;\n    undoControl = true;\n  } else if (item !== null && +item.val.value === +highlighted.val.value - 1) {\n    // check clicked item is correct for placing highlighted\n    removeCardOldPlace(highlighted, allCards); // remove card from old place\n\n    // add selected card to clicked card's next\n    item.next = highlighted;\n    undoControl = true;\n  } else {\n    // if not correct feedback to user and remove highlight\n    if (item === null) {\n      alert(\"Only A can be placed to blank columns\");\n    } else {\n      if (item !== highlighted) {\n        new Audio(wrongAudio).play();\n        alert(\"Incorrect Placement\");\n      }\n    }\n  }\n  removeHighlight(highlighted);\n  setCardDisplay(allCards);\n  return undoControl;\n};\nexport const getPrev = (allCards, find) => {\n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    if (element === null) {\n      continue;\n    }\n    while (element.next !== null) {\n      if (element.next === find) {\n        return element.val.show;\n      }\n      element = element.next;\n    }\n  }\n};\nexport const undoPlacement = (allCards, prevCards) => {\n  // Find prevCards' old position by it's old index\n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    if (prevCards.index === index) {\n      // when find check it is blank place or not\n      if (element === null) {\n        // if blank place directly\n        allCards[index] = prevCards.newHead;\n      } else {\n        // if not, need to place to last element\n        while (element.next !== null) {\n          element = element.next;\n        }\n        element.val.show = prevCards.status;\n        element.next = prevCards.newHead;\n      }\n    }\n  }\n};\nexport const getHint = (allCards, highlighted) => {\n  // check all cards for any eligible card for replacement\n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    while (element !== null) {\n      let next_value = +highlighted.val.value - 1;\n      let cur_value = +element.val.value;\n      // if found do replacement, remove card, remove it's highlight and set display\n      if (cur_value === next_value && element.val.show === true && element.next === null) {\n        removeCardOldPlace(highlighted, allCards);\n        element.next = highlighted;\n        removeHighlight(highlighted);\n        setCardDisplay(allCards);\n        return true;\n      }\n      element = element.next;\n    }\n  }\n  return false;\n};\nexport const undoDistribution = allCards => {\n  // get last cards of every column\n  let prevRemCards = [];\n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    while (element.next !== null) {\n      element = element.next;\n    }\n\n    // push cards into array\n    prevRemCards.push(new card(element.val.deck, element.val.value, false, false));\n    removeCardOldPlace(element, allCards); // remove last cards from board\n  }\n  return prevRemCards;\n};\nexport const hintControl = (item, control) => {\n  if (item !== null) {\n    let head = item; // need to hold head node because after control item's next, clicked item will be lost\n\n    while (item.next !== null) {\n      let next_value = +item.next.val.value - 1;\n      let cur_value = +item.val.value;\n      // check cards if in correct order\n      if (next_value !== cur_value) {\n        return false;\n      }\n      item = item.next;\n    }\n    // need to check control because of if item moved or to be moved\n    if (control) {\n      return item;\n    }\n    return head;\n  }\n};\nexport const doHighlight = async element => {\n  while (element !== null) {\n    element.val.active = true;\n    element = element.next;\n  }\n};\nexport const getCompleteHint = async allCards => {\n  const delay = ms => new Promise(res => setTimeout(res, ms));\n  for (let index = 0; index < allCards.length; index++) {\n    let element = allCards[index];\n    let elementNode;\n    let flag = true;\n    if (element === null) {\n      continue;\n    }\n    // pass undisplayed cards\n    while (element.val.show === false) {\n      element = element.next;\n    }\n    while (element !== null && flag) {\n      if (hintControl(element, true)) {\n        elementNode = hintControl(element, true);\n        flag = false; // if element found stop loop \n      } else {\n        element = element.next;\n      }\n    }\n    for (let index2 = 0; index2 < allCards.length; index2++) {\n      let element2 = allCards[index2];\n      let element2Node;\n      let flag = true;\n      let prev = element2;\n      if (element2 === null) {\n        continue;\n      }\n      // pass undisplayed cards\n      while (element2.val.show === false) {\n        element2 = element2.next;\n        prev = element2;\n      }\n      while (element2 !== null && flag) {\n        if (hintControl(element2, false)) {\n          element2Node = hintControl(element2, false);\n          flag = false; // if element found stop loop\n        } else {\n          prev = element2;\n          element2 = element2.next;\n        }\n      }\n\n      // check for eligibility\n      let next_value = +element2Node.val.value - 1;\n      let cur_value = +elementNode.val.value;\n\n      // if eligible show cards for 2 seconds\n      if (next_value === cur_value && +prev.val.value !== next_value) {\n        // highlight cards, wait, and remove highlight\n        await doHighlight(elementNode);\n        await doHighlight(element2Node);\n        await delay(2000);\n        await removeHighlight(elementNode);\n        await removeHighlight(element2Node);\n        return true;\n      }\n    }\n  }\n  return false;\n};","map":{"version":3,"names":["card","applauseAudio","wrongAudio","createLinked","element","Link","constructor","val","next","removeHighlight","remove","active","removeCardOldPlace","allCards","index","length","prev","undefined","setCardDisplay","show","anyBlank","clickGetCards","request","remCards","shift","checkComplete","complete","test","rank","next_value","value","cur_value","node","Audio","play","alert","firstClick","item","iter","head","secondClick","highlighted","undoControl","getPrev","find","undoPlacement","prevCards","newHead","status","getHint","undoDistribution","prevRemCards","push","deck","hintControl","control","doHighlight","getCompleteHint","delay","ms","Promise","res","setTimeout","elementNode","flag","index2","element2","element2Node"],"sources":["/Users/claudiufilip/Developer/personal-projects/spider-solitaire-ai/frontend/src/logic/Gameplay.js"],"sourcesContent":["import '../assets/css/card.css'\nimport { card } from './CardGenerator'\nimport applauseAudio from '../assets/sound/applause.mp3'\nimport wrongAudio from '../assets/sound/wrong.mp3'\n\nexport const createLinked = (element) => {\n    // remaining cards is array of objects but we need to transform every object to linked list object\n    class Link {\n        constructor(val) {\n            this.val = val\n            this.next = null\n        }\n    }\n    return new Link(element)\n}\n\nexport const removeHighlight = async (remove) => {\n    // remove card or cards activation/selected/red bordered\n    while (remove !== null) {\n        remove.val.active = false\n        remove = remove.next\n    }\n}\n\nexport const removeCardOldPlace = (remove, allCards) => {\n    // remove card from it's old place\n    for (let index = 0; index < allCards.length; index++) {\n        let element = allCards[index];\n        let prev\n        while (element !== null) {\n\n            if (element === remove) {\n                prev === undefined ? allCards[index] = null : prev.next = null // control for if column will not have any cards after placement\n            }\n            prev = element\n            element = element.next\n        }\n    }\n}\n\nexport const setCardDisplay = (allCards) => {\n    // traverse every card and set visibility to true if it's last element \n    for (let index = 0; index < allCards.length; index++) {\n        let element = allCards[index]\n        if (element !== null) {\n            while (element.next !== null) {\n                element = element.next\n            }\n            element.val.show = true;\n        }   \n    }\n}\n\nexport const anyBlank = (allCards) => {\n\n    // check if any blank column exist\n    for (let index = 0; index < allCards.length; index++) {\n        let element = allCards[index];\n\n        if (element === null) {\n            return false\n        }\n    }\n    return true\n}\n\nexport const clickGetCards = (request, allCards, remCards) => {\n\n    // check request bcs only 5 * 10 cards will distribute\n        request += 1\n        // add new cards to placing cards\n        for (let index = 0; index < allCards.length; index++) {\n            let element = allCards[index];\n            if (element === null) { // placing to empty columns\n                element = createLinked(remCards.shift())\n                allCards[index] = element\n            } else {\n                while (element.next !== null) {\n                    element = element.next\n                }\n                element.next = createLinked(remCards.shift())\n            }\n        }\n        setCardDisplay(allCards)\n        return {request, remCards}\n    \n}\n\nexport const checkComplete = (allCards, complete, test) => {\n    // traverse in every card and if rank reaches 13 means sorting complete\n    for (let index = 0; index < allCards.length; index++) {\n        let element = allCards[index];\n        let rank = 1\n        while (element !== null && element.next !== null) {\n            if (element.val.show === true) {\n                let next_value = +element.next.val.value - 1;\n                let cur_value = +element.val.value;\n                if (next_value === cur_value) {\n                    if (rank === 1) {\n                        var node = element // hold head node bcs if sorting complete, we will need to remove from that index\n                    }\n                    rank += 1\n                    if (rank === 13) {                        \n                        test && new Audio(applauseAudio).play()\n                        complete += 1\n                        removeCardOldPlace(node, allCards)\n                        test && alert(\"You Have Completed a Deck\")\n                    }\n                } else rank = 1 // reset rank value for new deck\n            }\n            element = element.next\n        }\n    }\n    setCardDisplay(allCards)\n    return {node, complete}\n}\n\nexport const firstClick = (item) => {\n    if (item !== null) {\n        let iter = 0; // how many cards will be select\n        let head = item; // need to hold head node because after control item's next, clicked item will be lost\n\n        while (item.next !== null) {\n\n            let next_value = +item.next.val.value - 1;\n            let cur_value = +item.val.value;\n            // check cards if in correct order\n            if (next_value !== cur_value || item.val.show === false) {\n                return false\n            }\n\n            item = item.next\n            iter += 1\n        }\n        let node = head\n\n        // if every item under clicked item have correct sort, activate all\n        for (let index = 0; index <= iter; index++) {\n            head.val.active = true\n            head = head.next\n        } \n        return node\n    }   \n}\n\nexport const secondClick = (item, highlighted, allCards, index) => {\n    let undoControl = false\n    if (item === null) {\n        removeCardOldPlace(highlighted, allCards)\n        allCards[index] = highlighted\n        undoControl = true\n    } else if (item !== null && +item.val.value === +highlighted.val.value - 1) { // check clicked item is correct for placing highlighted\n        removeCardOldPlace(highlighted, allCards) // remove card from old place\n\n        // add selected card to clicked card's next\n        item.next = highlighted\n        undoControl = true\n        \n    } else {\n        // if not correct feedback to user and remove highlight\n        if(item === null) {\n            alert(\"Only A can be placed to blank columns\")\n        } \n        else {\n            if(item !== highlighted){\n                new Audio(wrongAudio).play()\n                alert(\"Incorrect Placement\") \n            }\n        }\n    }\n    removeHighlight(highlighted)\n    setCardDisplay(allCards)\n    return undoControl\n}\n\nexport const getPrev = (allCards, find) => {\n    for (let index = 0; index < allCards.length; index++) {\n        let element = allCards[index];\n\n        if (element === null) {\n            continue\n        }\n\n        while (element.next!==null) {\n            if (element.next === find) {\n                 return element.val.show\n            }\n            element = element.next\n        }\n    }\n}\n\nexport const undoPlacement = (allCards, prevCards) => {\n    // Find prevCards' old position by it's old index\n    for (let index = 0; index < allCards.length; index++) {\n        let element = allCards[index];\n        if (prevCards.index === index) {\n            // when find check it is blank place or not\n            if (element === null) {\n                // if blank place directly\n                allCards[index] = prevCards.newHead\n            } else{\n                // if not, need to place to last element\n                while (element.next !== null) {\n                    element = element.next\n                }\n                element.val.show = prevCards.status\n                element.next = prevCards.newHead\n            }\n        }\n    }\n}\n\nexport const getHint = (allCards, highlighted) => {\n    // check all cards for any eligible card for replacement\n    for (let index = 0; index < allCards.length; index++) {\n        let element = allCards[index];\n        while (element !== null) {\n\n            let next_value = +highlighted.val.value - 1;\n            let cur_value = +element.val.value;\n            // if found do replacement, remove card, remove it's highlight and set display\n            if ((cur_value) === (next_value) && element.val.show === true && element.next === null) {\n                removeCardOldPlace(highlighted, allCards)\n                element.next = highlighted\n                removeHighlight(highlighted)\n                setCardDisplay(allCards)\n\n                return true\n            }\n            element = element.next\n        }\n    }\n    return false\n}\n\nexport const undoDistribution = (allCards) => {\n    // get last cards of every column\n    let prevRemCards = []\n    for (let index = 0; index < allCards.length; index++) {\n        let element = allCards[index];\n\n        while (element.next!==null) {\n            element = element.next\n        }\n        \n        // push cards into array\n        prevRemCards.push(new card(element.val.deck, element.val.value, false, false))\n        removeCardOldPlace(element, allCards) // remove last cards from board\n    }\n\n    return prevRemCards\n}\n\nexport const hintControl = (item, control) => {\n    if (item !== null) {\n        let head = item; // need to hold head node because after control item's next, clicked item will be lost\n\n        while (item.next !== null) {\n\n            let next_value = +item.next.val.value - 1;\n            let cur_value = +item.val.value;\n            // check cards if in correct order\n            if (next_value !== cur_value) {\n                    return false\n            }\n\n            item = item.next\n        }\n        // need to check control because of if item moved or to be moved\n        if (control) {\n            return item\n        }\n\n        return head\n    }\n}\n\nexport const doHighlight = async (element) => {\n    while (element !== null) {\n        element.val.active = true\n        element = element.next\n    }\n}\n\nexport const getCompleteHint = async (allCards) => {\n\n    const delay = ms => new Promise(res => setTimeout(res, ms));\n\n    for (let index = 0; index < allCards.length; index++) {\n        let element = allCards[index];\n        let elementNode\n        let flag = true\n\n        if (element === null) {\n            continue\n        }\n        // pass undisplayed cards\n        while (element.val.show === false) {\n            element = element.next\n        }\n        \n        while (element !== null && flag) {\n            if (hintControl(element, true)) {\n                elementNode = hintControl(element, true)\n                flag = false // if element found stop loop \n            } else {\n                element = element.next\n            }\n        }\n\n        for (let index2 = 0; index2 < allCards.length; index2++) {\n            let element2 = allCards[index2]\n            let element2Node\n            let flag = true\n            let prev = element2\n\n            if (element2 === null) {\n                continue\n            }\n            // pass undisplayed cards\n            while (element2.val.show === false) {\n                element2 = element2.next\n                prev = element2\n            }\n\n            while (element2 !== null && flag) {\n                if (hintControl(element2, false)) {\n                    element2Node = hintControl(element2, false)\n                    flag = false // if element found stop loop\n                } else {\n                    prev = element2\n                    element2 = element2.next\n                }\n            }\n\n            // check for eligibility\n            let next_value = +element2Node.val.value - 1;\n            let cur_value = +elementNode.val.value;\n\n            // if eligible show cards for 2 seconds\n            if (next_value === cur_value && +prev.val.value !== next_value) {\n                // highlight cards, wait, and remove highlight\n                await doHighlight(elementNode)\n                await doHighlight(element2Node)\n\n                await delay(2000)\n                \n                await removeHighlight(elementNode)\n                await removeHighlight(element2Node)\n\n                return true\n            }\n        }\n    }\n    return false\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}